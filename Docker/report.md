# Лабораторная работа №2

- [Задание](#задание)
- [Установка Docker](#установка-docker)
- [Плохой Dockerfile](#плохой-dockerfile)
- [Хороший Dockerfile](#хороший-dockerfile)
- [Тестируем](#тестируем)
- ["BAD PRACTICES" в работе с контейнерами]("bad-practices"-в-работе-с-контейнерами)
- [Выводы](#выводы)

## Задания: 

1. Написать “плохой” Dockerfile, в котором есть не менее трех “bad practices” по написанию докерфайлов;
2. Написать “хороший” Dockerfile, в котором эти плохие практики исправлены;
3. В Readme описать каждую из плохих практик в плохом докерфайле, почему она плохая и как в хорошем она была исправлена, как исправление повлияло на результат;
4. В Readme описать 2 плохих практики по работе с контейнерами. ! Не по написанию докерфайлов, а о том, как даже используя хороший докерфайл можно накосячить именно в работе с контейнерами.

![image](https://github.com/user-attachments/assets/3bf84cd3-b063-4a2e-aa6c-4322892d9371)


## Установка Docker

> Перед началом уточним, что работаем мы на ОС **Ubuntu 24.04 LTS**. Теперь можем начинать!

* Для установки Docker перейдем на официальный сайт `https://www.docker.com/get-started/`. Вы можете выбрать для себя более удобный способ установки, но мы воспользуемся консолью и выполним следующие команды:
```
# Add Docker's official GPG key:
sudo apt-get update
sudo apt-get install ca-certificates curl
sudo install -m 0755 -d /etc/apt/keyrings
sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
sudo chmod a+r /etc/apt/keyrings/docker.asc

# Add the repository to Apt sources:
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
  $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update

# To install the latest version, run:
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
```
* Если при выполнении команд не возникло ошибок, то поздравляем - Docker успешно установлен!
* На всякий случай проверим, что все работает, запустив приветствующий образ - `sudo docker run hello-world`.

![image](https://github.com/user-attachments/assets/a6e1c82c-75a6-45d1-b570-fe6dbfdb160e)

## Плохой Dockerfile

* Напишем плохой Dokcerfile, который будет запускать скрипт, выводящий сообщение в консоль. Потом разберемся с ошибками при написании Docker-файла и исправим их.

```
# Используем базовый образ Ubuntu
FROM ubuntu:latest

# Обновляем все пакеты в системе
RUN apt-get update && apt-get upgrade -y

# Указываем рабочую директорию
WORKDIR /app

# Копируем все файлы из текущей директории в контейнер
COPY . /app

# Запускаем наш скрипт
CMD ["./script.sh"]
```

## Хороший Dockerfile

* Начнем с разбора ошибок: 
1. `FRMO ubuntu:latest` - образ Ubuntu, особенно версия `latest`, довольно большой по размеру и включает в себя много пакетов и утилит, которые могут быть ненужными для реализации вашего приложения. Это приводит к увелечению размера будущего образа и времени развертывания контейнера. Также `latest` означает, что наше приложение всегда будет работать на самой последней версии Ubuntu, что может привести к непредсказуемому поведению. В результате чего наше приложение может не запуститься. Лучшей практикой будет использование, конкретных (минимальных образов), удовлетворяющих конкртеным задачам приложения.
2. `RUN apt-get update && apt-get upgrade -y` - использование данной команды в Dockerfile для обновления всех пакетов также является плохой практикой. Эта команда делает сборку образа нестабильной и непредсказуемой. Например, образ может работать как только вы его написали и собрали, но при повторной сборке через несколько месяцев могут возникнуть ошибки из-за того, что пакеты обновились и какие-то связи поменялись. Вместо обновления всех пакетов лучше устанавливать только необходимые пакеты конретных версий, чтобы гарантировать ожидаемое поведение сборки.
3. `COPY . /app` - эта команда копирует все файлы и директории из текущего рабочего каталога (директории) на хосте в рабочую директорию `/app` в контейнере. В результате чего мы можем скопировать как необходимые нам файлы, так и ненужные, что увеличивает размер будущего образа и приводит к непредсказуемому поведению и возникновению ошибок. Одним из вариантов исправление этой ошибки является добавление `.dockerignire`-файла, в котором мы прописываем название файлов и директорий, которые нам не нужны. Например:
```
# .dockerignore
.git
node_modules
*.log
*.tmp
*.bak
.vscode
```
* С ошибками разобрались. Давайте же посмотрим на исправленный Dockerfile.

```
# В качестве базового образа возьмем Alpine версии 3.14
FROM alpine:3.14

# Устанавливаем Bash версии - bash=5.1.16-r0
RUN apk add --no-cache bash=5.1.16-r0

# Указываем рабочую директорию
WORKDIR /app

# Копируем наш скрипт
COPY script.sh /app

# Делаем скрипт исполняемым
RUN chmod +x script.sh

# Запускаем bash-скрипт
CMD ["bash", "./script.sh"]
```
* Что поменялось?
* Во-первых, `FROM alpine:3.14` - тут в качестве базового образа мы используем Alpine Linux версии 3.14 (это легкий и минимальный дистрибутив). Его использование удовлетворяет задачам нашего приложения, при этом мы значительно уменьшаем размер контейнера.
* Во-вторых, `RUN apk add --no-cache bash=5.1.16-r0` - здесь мы используем пакетный менеджер Alpine (`apk`) для установки только конкретной версии Bash. Так мы изебгаем обновления всех пактов в системе, что может привести к непредсказуемому поведению в работе контейнера, и добавляем тоелько то, что надо для реализации нашего приложения. Также при помощи флага `--no-cache` мы убираем сохранение кэша, что уменьшает размер контенера.
* В-третьих, `COPY script.sh /app` - мы копируем только нужные файлы в контейнер (в нашем случае это наш `script.sh`).
* Дальше же мы явно устанавливаем нашему скрипту права на исполнение и запускаем срипт.

## Тестируем

* Собираем образ "хорошего" Dockerfile и запскаем контейнер:

![Снимок экрана от 2024-10-14 14-30-30](https://github.com/user-attachments/assets/4656f67b-db2b-4ed4-8c22-df265fa0ecf1)

![Снимок экрана от 2024-10-14 14-32-07](https://github.com/user-attachments/assets/5355fd48-699c-411e-8d1d-795652a6e7a1)

* Проделываем тоже самое с "плохим" Dockerfile:

![Снимок экрана от 2024-10-14 14-39-57](https://github.com/user-attachments/assets/0a8bbab6-5a96-4cda-817f-d4d070508ccd)

![Снимок экрана от 2024-10-14 14-47-15](https://github.com/user-attachments/assets/d9e63546-fadb-42f5-9a98-8cfd445ef665)

* Также давайте посмотрим на размеры полученных изображений.

![image](https://github.com/user-attachments/assets/cffc9e72-ad4d-4eef-a31f-6ab992eff108)


* Как мы можем видеть работа надо ошибками была проделана не зря. Помимо того, что образ на основе "хорошего" Dockerfile собрался намного быстрее чем на плохом, так еще и получившийся образ в несколько раз меньше по размеру чем образ, построенный по интсрукциям в "плохом" Dockerfile. Также мы при запуске `bad_docker` мы получили ошибку, что не удивительно, так как мы не указали права на исполнение нашему скрипту.

## "BAD PRACTICES" в работе с контейнерами

1. Запуск контейнера с привелегиями `root`

* По умолчанию многие контейнеры запускаются с правами **root**, что предоставляет контейнеру доступ к системным ресурсам и потенциально может представлять угрозу безопасности. Запуск контейнера с такими привилегиями увеличивает риск, что злоумышленник, нашедший уязвимость в приложении внутри контейнера, получит доступ к основной системе. Чтобы избежать этого старайтесь используйте непривилегированные учетные записи внутри контейнера. Можно создать нового пользователя в Dockerfile и запускать контейнер от его имени, используя команду `USER`. Также на стороне запуска контейнера стоит избегать флага `--privileged` и управлять доступом через специальные параметры Docker.

2. Отсутствие ограничения использования ресурсов контейнерами

* Если не ограничивать использование **CPU**, **памяти** и **других ресурсов** при запуске контейнера, это может привести к тому, что один контейнер будет использовать слишком много ресурсов, влияя на общую производительность системы. Например, контейнер с бесконечным циклом или неправильной конфигурацией может потреблять все доступные ресурсы CPU или памяти, что приведет к сбоям других контейнеров и системы в целом. Одни из решений является использование флагов `--memory`, `--cpus` при запуске контейнера. Например:
```
docker run --memory=512m --cpus=1 my_container
```

## Выводы

* В данной работе мы научились устанавливать **Docker**.
* Потренировались в написании Docker-файлов.
* Разобрали некоторые ошибки, которые встречаются при написании Docker-файлов.
* Исправили эти ошибки.
* Создали образы и запустили контейнеры
* Также узнали о том какие существуют ошибки при работе с контейнерами.
